query                      = [find-spec return-map-spec? with-clause? inputs? where-clauses?]
find-spec                  = ':find' (find-rel | find-coll | find-tuple | find-scalar)
return-map                 = (return-keys | return-syms | return-strs)
find-rel                   = find-elem+
find-coll                  = [find-elem '...']
find-scalar                = find-elem '.'
find-tuple                 = [find-elem+]
find-elem                  = (variable | pull-expr | aggregate)
return-keys                = ':keys' symbol+
return-syms                = ':syms' symbol+
return-strs                = ':strs' symbol+
pull-expr                  = ['pull' variable pattern]
pattern                    = (pattern-name | pattern-data-literal)
aggregate                  = [aggregate-fn-name fn-arg+]
fn-arg                     = (variable | constant | src-var)
with-clause                = ':with' variable+
where-clauses              = ':where' clause+
inputs                     = ':in' (src-var | binding | pattern-name | rules-var)+
src-var                    = symbol starting with "$"
variable                   = symbol starting with "?"
rules-var                  = the symbol "%"
plain-symbol               = symbol that does not begin with "$" or "?"
pattern-name               = plain-symbol
and-clause                 = [ 'and' clause+ ]
expression-clause          = (data-pattern | pred-expr | fn-expr | rule-expr)
rule-expr                  = [ src-var? rule-name (variable | constant | '_')+]
not-clause                 = [ src-var? 'not' clause+ ]
not-join-clause            = [ src-var? 'not-join' [variable+] clause+ ]
or-clause                  = [ src-var? 'or' (clause | and-clause)+]
or-join-clause             = [ src-var? 'or-join' rule-vars (clause | and-clause)+ ]
rule-vars                  = [variable+ | ([variable+] variable*)]
clause                     = (not-clause | not-join-clause | or-clause | or-join-clause | expression-clause)
data-pattern               = [ src-var? (variable | constant | '_')+ ]
constant                   = any non-variable data literal
pred-expr                  = [ [pred fn-arg+] ]
fn-expr                    = [ [fn fn-arg+] binding]
binding                    = (bind-scalar | bind-tuple | bind-coll | bind-rel)
bind-scalar                = variable
bind-tuple                 = [ (variable | '_')+]
bind-coll                  = [variable '...']
bind-rel                   = [ [(variable | '_')+] ]


[[sally :age 21] 
 [fred :age 42] 
 [ethel :age 42]
 [fred :likes pizza] 
 [sally :likes opera] 
 [ethel :likes sushi]]


[:find ?e 
 :where [?e :age 42]]

=> [[fred], [ethel]]


-------------------------------------------------------------------------------

-------------------------------------------------------------------------------

;; query
[:find ?release-name
 :in $ ?artist-name
 :where [?artist :artist/name ?artist-name]
        [?release :release/artists ?artist]
        [?release :release/name ?release-name]]

;; inputs
db, "John Lennon"

-------------------------------------------------------------------------------

https://www.youtube.com/watch?v=ikVZrivln8c
https://www.cnblogs.com/RDaneelOlivaw/p/8072603.html

verify rules match facts
let model = solve(facts, rules)
project(model)

-------------------------------------------------------------------------------

[[lenon :artist/name "John Lenon"]
 [paul :artist/name "Paul McCartney"]
 [rel1 :release/artists lenon]
 [rel1 :release/artists paul]
 [rel1 :release/name "Release #1"]
 [rel2 :release/artists paul]
 [rel2 :release/name "Release #2"]]

# 1. Var to clause
?artist
  e: [?artist :artist/name "John Lenon"] 
  v: [?release :release/artists ?artist]

?release
  e: [?release :release/artists ?artist]
  e: [?release :release/name ?release-name]

?release-name
  v: [?release :release/name ?release-name]

# 2. Clause to datoms
[?artist :artist/name "John Lenon"]
  [lenon :artist/name "John Lenon"]
  ?artist => [lenon]

[?release :release/artists ?artist]
  [rel1 :release/artists lenon]
  [rel1 :release/artists paul]
  [rel2 :release/artists paul]
  ?release => [rel1]
  ?artist => [lenon]

[?release :release/name ?release-name]
  [rel1 :release/name "Release #1"]
  [rel2 :release/name "Release #2"]
  ?release => [rel1]
  ?release-name => ["Release #1]

# 3. Var to datoms
?artist
  e: [lenon]
  <intersect>
  :v [lenon, paul]
  = [lenon]

?release
  e: [rel1, rel2]
  <intersect>
  e: [rel1, rel2]
  = [rel1, rel2]

?release-name


-------------------------------------------------------------------------------



https://freecontent.manning.com/constraint-satisfaction-problems-in-python/

# create_entity_by_temp_id

[john :artist/name "John Lenon"]
[paul :artist/name "Paul McCartney"]
[ar :release/name "Abbey Road"]
[ar :release/artists john]
[ar :release/artists paul]
[ram :release/name "Ram"]
[ram :release/artists paul]
[imagine :release/name "Imagine"]
[imagine :release/artists john]


[:find ?release-name
 :where [?artist :artist/name "John Lenon"]
        [?release :release/artists ?artist]
        [?release :release/name ?release-name]]



c1:[?artist :artist/name "John Lenon"]
c2:[?release :release/artists ?artist]
c3:[?release :release/name ?release-name]


Variables:
-
?artist
?release
?release-name



c1:[?artist :artist/name "John Lenon"]
  d:[john :artist/name "John Lenon"] => {?artist => john}
    c2:[?release :release/artists john]
      d:[ar :release/artists john] => {?artist => john, ?release => ar}
        c3:[ar :release/name ?release-name]
          d:[ar :release/name "Abbey Road"] => {?artist => john, ?release => ar, ?release-name => "Abbey Road"} Complete!
      d:[imagine :release/artists john] => {?artist => john, ?release => imagine}
        c3:[imagine :release/name ?release-name]
          d:[imagine :release/name "Imagine"] => {?artist => john, ?release => imagine, ?release-name => "Imagine"} Complete!













-------------------------------------------------------------------------------

// Foo -> Bar -> Baz -> Qux
[foo :name "Foo"]
[bar :name "Bar"]
[baz :name "Baz"]
[qux :name "Qux"]
[foo :parent bar]
[bar :parent baz]
[baz :parent qux]

[:find [?grandson-name ?grandparent-name]
 :where [?grandparent :parent ?parent]
        [?parent :parent ?grandson]
        [?grandparent :name ?grandparent-name]
        [?grandson :name ?grandson-name]]


c1:[?grandparent :parent ?parent]
-
[foo :parent bar] => {?grandparent => foo, ?parent => bar}
[bar :parent baz] => {?grandparent => bar, ?parent => baz}
[baz :parent qux] => {?grandparent => baz, ?parent => qux}


c2:[?parent :parent ?grandson]
-
[foo :parent bar] => {?parent => foo, ?grandson => bar}
[bar :parent baz] => {?parent => bar, ?grandson => baz}
[baz :parent qux] => {?parent => baz, ?grandson => qux}


c3:[?grandparent :name ?grandparent-name]
-
[foo :name "Foo"] => {?grandparent => foo, ?grandparent-name => "Foo"}
[bar :name "Bar"] => {?grandparent => bar, ?grandparent-name => "Bar"}
[baz :name "Baz"] => {?grandparent => baz, ?grandparent-name => "Baz"}
[qux :name "Qux"] => {?grandparent => qux, ?grandparent-name => "Qux"}


c4:[?grandson :name ?grandson-name]
-
[foo :name "Foo"] => {?grandson => foo, ?grandson-name => "Foo"}
[bar :name "Bar"] => {?grandson => bar, ?grandson-name => "Bar"}
[baz :name "Baz"] => {?grandson => baz, ?grandson-name => "Baz"}
[qux :name "Qux"] => {?grandson => qux, ?grandson-name => "Qux"}


Variables
-
?grandparent
?parent
?grandson
?grandparent-name
?grandson-name


c1:[?grandparent :parent ?parent]
  d:[foo :parent bar] => {?grandparent => foo, ?parent => bar}
    c2:[bar :parent ?grandson]
      d:[bar :parent baz] => {?grandparent => foo, ?parent => bar, ?grandson => baz}
        c3:[foo :name ?grandparent-name]
          d:[foo :name "Foo"] => {?grandparent => foo, ?parent => bar, ?grandson => baz, ?grandparent-name => "Foo"}
            c4:[baz :name ?grandson-name]
              d:[baz :name "Baz"] => {?grandparent => foo, ?parent => bar, ?grandson => baz, ?grandparent-name => "Foo", ?grandson-name => "Baz"} Valid assignment!
  d:[bar :parent baz] => {?grandparent => bar, ?parent => baz}
    c2:[baz :parent ?grandson]
      d:[baz :parent qux] => {?grandparent => bar, ?parent => baz, ?grandson => qux}
        c3:[bar :name ?grandparent-name]
          d:[bar :name "Bar"] => {?grandparent => bar, ?parent => baz, ?grandson => qux, ?gradparent-name => "Bar"}
            c4:[qux :name ?grandson-name]
              d:[qux :name "Qux"] => {?grandparent => bar, ?parent => baz, ?grandson => qux, ?grandparent-name => "Bar", ?grandson-name => "Qux"} Valid assignment!
  d:[baz :parent qux] => {?grandparent => baz, ?parent => qux}
    c2:[qux :parent ?grandson]
      d:None => invalid assignment!



-------------------------------------------------------------------------------

db datoms

[1 1 "db/attr/ident"]
[1 3 type/str]
[1 4 cardinality/one]
[10 1 "person/name"]
[10 3 type/str]
[10 4 cardinality/one]
[11 10 "John"]

ident_to_entity {
  "db/attr/ident" => 1
  "person/name" => 10
}

query

[:find ?john
 :where [[?john "person/name" "John"]]]

# 1. Var to clause
?john => [?john "person/name" "John"]

# 2. Clause to datoms
[?john "person/name" "John"]
  

Expected result => [[11]]

sort clauses by grounded terms
resolve idents
for clause in clauses:
  for datom in datoms:
    if (datom satisfies clause):
      facts += datom

    
substitution step
  1) attribute ident => ID
  2) ref?
[?john "person/name" "John"] => [?john 10 "John"]

Iter #1
clause [?john 10 "John"]
datom [1 1 "db/attr/ident"]
satisfy => false

Iter #2
clause [?john 10 "John"]
datom [1 3 type/str]
satisfy => false

Iter #3
clause [?john 10 "John"]
datom [1 4 cardinality/one]
satisfy => false

Iter #4
clause [?john 10 "John"]
datom [10 1 10]
satisfy => false

Iter #5
clause [?john 10 "John"]
datom [10 3 type/str]
satisfy => false

Iter #6
clause [?john 10 "John"]
datom [10 4 cardinality/one]
satisfy => false

Iter #7
clause [?john 10 "John"]
datom [11 10 "John"]
satisfy => true





























