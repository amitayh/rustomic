query                      = [find-spec return-map-spec? with-clause? inputs? where-clauses?]
find-spec                  = ':find' (find-rel | find-coll | find-tuple | find-scalar)
return-map                 = (return-keys | return-syms | return-strs)
find-rel                   = find-elem+
find-coll                  = [find-elem '...']
find-scalar                = find-elem '.'
find-tuple                 = [find-elem+]
find-elem                  = (variable | pull-expr | aggregate)
return-keys                = ':keys' symbol+
return-syms                = ':syms' symbol+
return-strs                = ':strs' symbol+
pull-expr                  = ['pull' variable pattern]
pattern                    = (pattern-name | pattern-data-literal)
aggregate                  = [aggregate-fn-name fn-arg+]
fn-arg                     = (variable | constant | src-var)
with-clause                = ':with' variable+
where-clauses              = ':where' clause+
inputs                     = ':in' (src-var | binding | pattern-name | rules-var)+
src-var                    = symbol starting with "$"
variable                   = symbol starting with "?"
rules-var                  = the symbol "%"
plain-symbol               = symbol that does not begin with "$" or "?"
pattern-name               = plain-symbol
and-clause                 = [ 'and' clause+ ]
expression-clause          = (data-pattern | pred-expr | fn-expr | rule-expr)
rule-expr                  = [ src-var? rule-name (variable | constant | '_')+]
not-clause                 = [ src-var? 'not' clause+ ]
not-join-clause            = [ src-var? 'not-join' [variable+] clause+ ]
or-clause                  = [ src-var? 'or' (clause | and-clause)+]
or-join-clause             = [ src-var? 'or-join' rule-vars (clause | and-clause)+ ]
rule-vars                  = [variable+ | ([variable+] variable*)]
clause                     = (not-clause | not-join-clause | or-clause | or-join-clause | expression-clause)
data-pattern               = [ src-var? (variable | constant | '_')+ ]
constant                   = any non-variable data literal
pred-expr                  = [ [pred fn-arg+] ]
fn-expr                    = [ [fn fn-arg+] binding]
binding                    = (bind-scalar | bind-tuple | bind-coll | bind-rel)
bind-scalar                = variable
bind-tuple                 = [ (variable | '_')+]
bind-coll                  = [variable '...']
bind-rel                   = [ [(variable | '_')+] ]


[[sally :age 21] 
 [fred :age 42] 
 [ethel :age 42]
 [fred :likes pizza] 
 [sally :likes opera] 
 [ethel :likes sushi]]


[:find ?e 
 :where [?e :age 42]]

=> [[fred], [ethel]]

-------------------------------------------------------------------------------

-------------------------------------------------------------------------------

;; query
[:find ?release-name
 :in $ ?artist-name
 :where [?artist :artist/name ?artist-name]
        [?release :release/artists ?artist]
        [?release :release/name ?release-name]]

;; inputs
db, "John Lennon"

-------------------------------------------------------------------------------

[[lenon :artist/name "John Lenon"]
 [paul :artist/name "Paul McCartney"]
 [rel1 :release/artists lenon]
 [rel1 :release/artists paul]
 [rel1 :release/name "Release #1"]
 [rel2 :release/artists paul]
 [rel2 :release/name "Release #2"]]

# 1. Var to clause
?artist
  e: [?artist :artist/name "John Lenon"] 
  v: [?release :release/artists ?artist]

?release
  e: [?release :release/artists ?artist]
  e: [?release :release/name ?release-name]

?release-name
  v: [?release :release/name ?release-name]

# 2. Clause to datoms
[?artist :artist/name "John Lenon"]
  [lenon :artist/name "John Lenon"]
  ?artist => [lenon]

[?release :release/artists ?artist]
  [rel1 :release/artists lenon]
  [rel1 :release/artists paul]
  [rel2 :release/artists paul]
  ?release => [rel1]
  ?artist => [lenon]

[?release :release/name ?release-name]
  [rel1 :release/name "Release #1"]
  [rel2 :release/name "Release #2"]
  ?release => [rel1]
  ?release-name => ["Release #1]

# 3. Var to datoms
?artist
  e: [lenon]
  <intersect>
  :v [lenon, paul]
  = [lenon]

?release
  e: [rel1, rel2]
  <intersect>
  e: [rel1, rel2]
  = [rel1, rel2]

?release-name








[[john :artist/name "John Lenon"]
 [paul :artist/name "Paul McCartney"]
 [ar :release/name "Abbey Road"
 [ar :release/artusts john]]

-------------------------------------------------------------------------------

db datoms

[1 1 "db/attr/ident"]
[1 3 type/str]
[1 4 cardinality/one]
[10 1 "person/name"]
[10 3 type/str]
[10 4 cardinality/one]
[11 10 "John"]

ident_to_entity {
  "db/attr/ident" => 1
  "person/name" => 10
}

query

[:find ?john
 :where [[?john "person/name" "John"]]]

# 1. Var to clause
?john => [?john "person/name" "John"]

# 2. Clause to datoms
[?john "person/name" "John"]
  

Expected result => [[11]]

sort clauses by grounded terms
resolve idents
for clause in clauses:
  for datom in datoms:
    
substitution step
  1) attribute ident => ID
  2) ref?
[?john "person/name" "John"] => [?john 10 "John"]

Iter #1
clause [?john 10 "John"]
datom [1 1 "db/attr/ident"]
satisfy => false

Iter #2
clause [?john 10 "John"]
datom [1 3 type/str]
satisfy => false

Iter #3
clause [?john 10 "John"]
datom [1 4 cardinality/one]
satisfy => false

Iter #4
clause [?john 10 "John"]
datom [10 1 10]
satisfy => false

Iter #5
clause [?john 10 "John"]
datom [10 3 type/str]
satisfy => false

Iter #6
clause [?john 10 "John"]
datom [10 4 cardinality/one]
satisfy => false

Iter #7
clause [?john 10 "John"]
datom [11 10 "John"]
satisfy => true





























